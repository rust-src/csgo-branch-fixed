//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once

//*****************************************************************************
//
// Notes on the ETW event code generated by MC:
//
// - Structures and arrays of structures are treated as an opaque binary blob.
//   The caller is responsible for packing the data for the structure into a
//   single region of memory, with no padding between values. The macro will
//   have an extra parameter for the length of the blob.
// - Arrays of nul-terminated strings must be packed by the caller into a
//   single binary blob containing the correct number of strings, with a nul
//   after each string. The size of the blob is specified in characters, and
//   includes the final nul.
// - Arrays of SID are treated as a single binary blob. The caller is
//   responsible for packing the SID values into a single region of memory with
//   no padding.
// - The length attribute on the data element in the manifest is significant
//   for values with intype win:UnicodeString, win:AnsiString, or win:Binary.
//   The length attribute must be specified for win:Binary, and is optional for
//   win:UnicodeString and win:AnsiString (if no length is given, the strings
//   are assumed to be nul-terminated). For win:UnicodeString, the length is
//   measured in characters, not bytes.
// - For an array of win:UnicodeString, win:AnsiString, or win:Binary, the
//   length attribute applies to every value in the array, so every value in
//   the array must have the same length. The values in the array are provided
//   to the macro via a single pointer -- the caller is responsible for packing
//   all of the values into a single region of memory with no padding between
//   values.
// - Values of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary can be generated and collected on Vista or later.
//   However, they may not decode properly without the Windows 10 2018 Fall
//   Update.
// - Arrays of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary must be packed by the caller into a single region of
//   memory. The format for each item is a UINT16 byte-count followed by that
//   many bytes of data. When providing the array to the generated macro, you
//   must provide the total size of the packed array data, including the UINT16
//   sizes for each item. In the case of win:CountedUnicodeString, the data
//   size is specified in WCHAR (16-bit) units. In the case of
//   win:CountedAnsiString and win:CountedBinary, the data size is specified in
//   bytes.
//
//*****************************************************************************

#include <wmistr.h>
#include <evntrace.h>
#include <evntprov.h>

#ifndef ETW_INLINE
  #ifdef _ETW_KM_
    // In kernel mode, save stack space by never inlining templates.
    #define ETW_INLINE DECLSPEC_NOINLINE __inline
  #else
    // In user mode, save code size by inlining templates as appropriate.
    #define ETW_INLINE __inline
  #endif
#endif // ETW_INLINE

#if defined(__cplusplus)
extern "C" {
#endif

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_USE_KERNEL_MODE_APIS macro:
// Controls whether the generated code uses kernel-mode or user-mode APIs.
// - Set to 0 to use Windows user-mode APIs such as EventRegister.
// - Set to 1 to use Windows kernel-mode APIs such as EtwRegister.
// Default is based on whether the _ETW_KM_ macro is defined (i.e. by wdm.h).
// Note that the APIs can also be overridden directly, e.g. by setting the
// MCGEN_EVENTWRITETRANSFER or MCGEN_EVENTREGISTER macros.
//
#ifndef MCGEN_USE_KERNEL_MODE_APIS
  #ifdef _ETW_KM_
    #define MCGEN_USE_KERNEL_MODE_APIS 1
  #else
    #define MCGEN_USE_KERNEL_MODE_APIS 0
  #endif
#endif // MCGEN_USE_KERNEL_MODE_APIS

//
// MCGEN_HAVE_EVENTSETINFORMATION macro:
// Controls how McGenEventSetInformation uses the EventSetInformation API.
// - Set to 0 to disable the use of EventSetInformation
//   (McGenEventSetInformation will always return an error).
// - Set to 1 to directly invoke MCGEN_EVENTSETINFORMATION.
// - Set to 2 to to locate EventSetInformation at runtime via GetProcAddress
//   (user-mode) or MmGetSystemRoutineAddress (kernel-mode).
// Default is determined as follows:
// - If MCGEN_EVENTSETINFORMATION has been customized, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else if the target OS version has EventSetInformation, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else set to 2 (i.e. try to dynamically locate EventSetInformation).
// Note that an McGenEventSetInformation function will only be generated if one
// or more provider in a manifest has provider traits.
//
#ifndef MCGEN_HAVE_EVENTSETINFORMATION
  #ifdef MCGEN_EVENTSETINFORMATION             // if MCGEN_EVENTSETINFORMATION has been customized,
    #define MCGEN_HAVE_EVENTSETINFORMATION   1 //   directly invoke MCGEN_EVENTSETINFORMATION(...).
  #elif MCGEN_USE_KERNEL_MODE_APIS             // else if using kernel-mode APIs,
    #if NTDDI_VERSION >= 0x06040000            //   if target OS is Windows 10 or later,
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EtwSetInformation" via MmGetSystemRoutineAddress.
    #endif                                     // else (using user-mode APIs)
  #else                                        //   if target OS and SDK is Windows 8 or later,
    #if WINVER >= 0x0602 && defined(EVENT_FILTER_TYPE_SCHEMATIZED)
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EventSetInformation" via GetModuleHandleExW/GetProcAddress.
    #endif
  #endif
#endif // MCGEN_HAVE_EVENTSETINFORMATION

//
// MCGEN Override Macros
//
// The following override macros may be defined before including this header
// to control the APIs used by this header:
//
// - MCGEN_EVENTREGISTER
// - MCGEN_EVENTUNREGISTER
// - MCGEN_EVENTSETINFORMATION
// - MCGEN_EVENTWRITETRANSFER
//
// If the the macro is undefined, the MC implementation will default to the
// corresponding ETW APIs. For example, if the MCGEN_EVENTREGISTER macro is
// undefined, the EventRegister[MyProviderName] macro will use EventRegister
// in user mode and will use EtwRegister in kernel mode.
//
// To prevent issues from conflicting definitions of these macros, the value
// of the override macro will be used as a suffix in certain internal function
// names. Because of this, the override macros must follow certain rules:
//
// - The macro must be defined before any MC-generated header is included and
//   must not be undefined or redefined after any MC-generated header is
//   included. Different translation units (i.e. different .c or .cpp files)
//   may set the macros to different values, but within a translation unit
//   (within a single .c or .cpp file), the macro must be set once and not
//   changed.
// - The override must be an object-like macro, not a function-like macro
//   (i.e. the override macro must not have a parameter list).
// - The override macro's value must be a simple identifier, i.e. must be
//   something that starts with a letter or '_' and contains only letters,
//   numbers, and '_' characters.
// - If the override macro's value is the name of a second object-like macro,
//   the second object-like macro must follow the same rules. (The override
//   macro's value can also be the name of a function-like macro, in which
//   case the function-like macro does not need to follow the same rules.)
//
// For example, the following will cause compile errors:
//
//   #define MCGEN_EVENTWRITETRANSFER MyNamespace::MyClass::MyFunction // Value has non-identifier characters (colon).
//   #define MCGEN_EVENTWRITETRANSFER GetEventWriteFunctionPointer(7)  // Value has non-identifier characters (parentheses).
//   #define MCGEN_EVENTWRITETRANSFER(h,e,a,r,c,d) EventWrite(h,e,c,d) // Override is defined as a function-like macro.
//   #define MY_OBJECT_LIKE_MACRO     MyNamespace::MyClass::MyEventWriteFunction
//   #define MCGEN_EVENTWRITETRANSFER MY_OBJECT_LIKE_MACRO // Evaluates to something with non-identifier characters (colon).
//
// The following would be ok:
//
//   #define MCGEN_EVENTWRITETRANSFER  MyEventWriteFunction1  // OK, suffix will be "MyEventWriteFunction1".
//   #define MY_OBJECT_LIKE_MACRO      MyEventWriteFunction2
//   #define MCGEN_EVENTWRITETRANSFER  MY_OBJECT_LIKE_MACRO   // OK, suffix will be "MyEventWriteFunction2".
//   #define MY_FUNCTION_LIKE_MACRO(h,e,a,r,c,d) MyNamespace::MyClass::MyEventWriteFunction3(h,e,c,d)
//   #define MCGEN_EVENTWRITETRANSFER  MY_FUNCTION_LIKE_MACRO // OK, suffix will be "MY_FUNCTION_LIKE_MACRO".
//
#ifndef MCGEN_EVENTREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTREGISTER        EtwRegister
  #else
    #define MCGEN_EVENTREGISTER        EventRegister
  #endif
#endif // MCGEN_EVENTREGISTER
#ifndef MCGEN_EVENTUNREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTUNREGISTER      EtwUnregister
  #else
    #define MCGEN_EVENTUNREGISTER      EventUnregister
  #endif
#endif // MCGEN_EVENTUNREGISTER
#ifndef MCGEN_EVENTSETINFORMATION
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTSETINFORMATION  EtwSetInformation
  #else
    #define MCGEN_EVENTSETINFORMATION  EventSetInformation
  #endif
#endif // MCGEN_EVENTSETINFORMATION
#ifndef MCGEN_EVENTWRITETRANSFER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTWRITETRANSFER   EtwWriteTransfer
  #else
    #define MCGEN_EVENTWRITETRANSFER   EventWriteTransfer
  #endif
#endif // MCGEN_EVENTWRITETRANSFER

//
// MCGEN_EVENT_ENABLED macro:
// Override to control how the EventWrite[EventName] macros determine whether
// an event is enabled. The default behavior is for EventWrite[EventName] to
// use the EventEnabled[EventName] macros.
//
#ifndef MCGEN_EVENT_ENABLED
#define MCGEN_EVENT_ENABLED(EventName) EventEnabled##EventName()
#endif

//
// MCGEN_EVENT_ENABLED_FORCONTEXT macro:
// Override to control how the EventWrite[EventName]_ForContext macros
// determine whether an event is enabled. The default behavior is for
// EventWrite[EventName]_ForContext to use the
// EventEnabled[EventName]_ForContext macros.
//
#ifndef MCGEN_EVENT_ENABLED_FORCONTEXT
#define MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EventName) EventEnabled##EventName##_ForContext(pContext)
#endif

//
// MCGEN_ENABLE_CHECK macro:
// Determines whether the specified event would be considered as enabled
// based on the state of the specified context. Slightly faster than calling
// McGenEventEnabled directly.
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled && McGenEventEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
// This structure is for use by MC-generated code and should not be used directly.
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE            RegistrationHandle;
    TRACEHANDLE            Logger;      // Used as pointer to provider traits.
    ULONGLONG              MatchAnyKeyword;
    ULONGLONG              MatchAllKeyword;
    ULONG                  Flags;
    ULONG                  IsEnabled;
    UCHAR                  Level;
    UCHAR                  Reserve;
    USHORT                 EnableBitsCount;
    PULONG                 EnableBitMask;
    const ULONGLONG*       EnableKeyWords;
    const UCHAR*           EnableLevel;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif // MCGEN_TRACE_CONTEXT_DEF

#if !defined(MCGEN_LEVEL_KEYWORD_ENABLED_DEF)
#define MCGEN_LEVEL_KEYWORD_ENABLED_DEF
//
// Determines whether an event with a given Level and Keyword would be
// considered as enabled based on the state of the specified context.
// Note that you may want to use MCGEN_ENABLE_CHECK instead of calling this
// function directly.
//
FORCEINLINE
BOOLEAN
McGenLevelKeywordEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((Keyword == (ULONGLONG)0) ||
            ((Keyword & EnableInfo->MatchAnyKeyword) &&
             ((Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // MCGEN_LEVEL_KEYWORD_ENABLED_DEF

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
//
// Determines whether the specified event would be considered as enabled based
// on the state of the specified context. Note that you may want to use
// MCGEN_ENABLE_CHECK instead of calling this function directly.
//
FORCEINLINE
BOOLEAN
McGenEventEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return McGenLevelKeywordEnabled(EnableInfo, EventDescriptor->Level, EventDescriptor->Keyword);
}
#endif // MCGEN_EVENT_ENABLED_DEF

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    _In_ LPCGUID SourceId,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
    _Inout_opt_ PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Windows Vista and later.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider.

    ControlCode - The parameter indicates whether the provider
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category
                      of events that the provider writes.

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
    ULONG Ix;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;

            for (Ix = 0; Ix < Ctx->EnableBitsCount; Ix += 1) {
                if (McGenLevelKeywordEnabled(Ctx, Ctx->EnableLevel[Ix], Ctx->EnableKeyWords[Ix]) != FALSE) {
                    Ctx->EnableBitMask[Ix >> 5] |= (1 << (Ix % 32));
                } else {
                    Ctx->EnableBitMask[Ix >> 5] &= ~(1 << (Ix % 32));
                }
            }
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            if (Ctx->EnableBitsCount > 0) {
#pragma warning(suppress: 26451) // Arithmetic overflow cannot occur, no matter the value of EnableBitCount
                RtlZeroMemory(Ctx->EnableBitMask, (((Ctx->EnableBitsCount - 1) / 32) + 1) * sizeof(ULONG));
            }
            break;

        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif // MCGEN_PRIVATE_ENABLE_CALLBACK_V2

    return;
}

#endif // MCGEN_CONTROL_CALLBACK

#ifndef _mcgen_PENABLECALLBACK
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define _mcgen_PENABLECALLBACK      PETWENABLECALLBACK
  #else
    #define _mcgen_PENABLECALLBACK      PENABLECALLBACK
  #endif
#endif // _mcgen_PENABLECALLBACK

#if !defined(_mcgen_PASTE2)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE2(a, b) _mcgen_PASTE2_imp(a, b)
#define _mcgen_PASTE2_imp(a, b) a##b
#endif // _mcgen_PASTE2

#if !defined(_mcgen_PASTE3)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE3(a, b, c) _mcgen_PASTE3_imp(a, b, c)
#define _mcgen_PASTE3_imp(a, b, c) a##b##_##c
#endif // _mcgen_PASTE3

//
// Macro validation
//

// Validate MCGEN_EVENTREGISTER:

// Trigger an error if MCGEN_EVENTREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER);

// Trigger an error if MCGEN_EVENTREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER)
    MCGEN_EVENTREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTREGISTER);

// Validate MCGEN_EVENTUNREGISTER:

// Trigger an error if MCGEN_EVENTUNREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER);

// Trigger an error if MCGEN_EVENTUNREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER)
    MCGEN_EVENTUNREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTUNREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTUNREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTUNREGISTER);

// Validate MCGEN_EVENTSETINFORMATION:

// Trigger an error if MCGEN_EVENTSETINFORMATION is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION);

// Trigger an error if MCGEN_EVENTSETINFORMATION is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION)
    MCGEN_EVENTSETINFORMATION_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTSETINFORMATION is defined as a function-like macro:
typedef void MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_MCGEN_EVENTSETINFORMATION;
typedef int _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_, MCGEN_EVENTSETINFORMATION);

// Validate MCGEN_EVENTWRITETRANSFER:

// Trigger an error if MCGEN_EVENTWRITETRANSFER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER);

// Trigger an error if MCGEN_EVENTWRITETRANSFER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER)
    MCGEN_EVENTWRITETRANSFER_must_not_be_redefined_between_headers;;

// Trigger an error if MCGEN_EVENTWRITETRANSFER is defined as a function-like macro:
typedef void MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_MCGEN_EVENTWRITETRANSFER;
typedef int _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_, MCGEN_EVENTWRITETRANSFER);

#ifndef McGenEventWrite_def
#define McGenEventWrite_def

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventWrite _mcgen_PASTE2(McGenEventWrite_, MCGEN_EVENTWRITETRANSFER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventWrite(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_range_(1, 128) ULONG EventDataCount,
    _Pre_cap_(EventDataCount) EVENT_DATA_DESCRIPTOR* EventData
    )
{
    const USHORT UNALIGNED* Traits;

    // Some customized MCGEN_EVENTWRITETRANSFER macros might ignore ActivityId.
    UNREFERENCED_PARAMETER(ActivityId);

    Traits = (const USHORT UNALIGNED*)(UINT_PTR)Context->Logger;

    if (Traits == NULL) {
        EventData[0].Ptr = 0;
        EventData[0].Size = 0;
        EventData[0].Reserved = 0;
    } else {
        EventData[0].Ptr = (ULONG_PTR)Traits;
        EventData[0].Size = *Traits;
        EventData[0].Reserved = 2; // EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA
    }

    return MCGEN_EVENTWRITETRANSFER(
        Context->RegistrationHandle,
        Descriptor,
        ActivityId,
        NULL,
        EventDataCount,
        EventData);
}
#endif // McGenEventWrite_def

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventRegister _mcgen_PASTE2(McGenEventRegister_, MCGEN_EVENTREGISTER)

#pragma warning(push)
#pragma warning(disable:6103)
// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ _mcgen_PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Inout_ PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function registers the provider with ETW.

Arguments:

    ProviderId - Provider ID to register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for the callback.

    RegHandle - Pointer to registration handle.

Remarks:

    Should not be called if the provider is already registered (i.e. should not
    be called if *RegHandle != 0). Repeatedly registering a provider is a bug
    and may indicate a race condition. However, for compatibility with previous
    behavior, this function will return SUCCESS in this case.

--*/
{
    ULONG Error;

    if (*RegHandle != 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTREGISTER(ProviderId, EnableCallback, CallbackContext, RegHandle);
    }

    return Error;
}
#pragma warning(pop)

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventUnregister _mcgen_PASTE2(McGenEventUnregister_, MCGEN_EVENTUNREGISTER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(_Inout_ PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW and set *RegHandle = 0.

Arguments:

    RegHandle - the pointer to the provider registration handle

Remarks:

    If provider has not been registered (i.e. if *RegHandle == 0),
    return SUCCESS. It is safe to call McGenEventUnregister even if the
    call to McGenEventRegister returned an error.

--*/
{
    ULONG Error;

    if(*RegHandle == 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTUNREGISTER(*RegHandle);
        *RegHandle = (REGHANDLE)0;
    }

    return Error;
}

#endif // McGenEventRegisterUnregister

#ifndef _mcgen_EVENT_BIT_SET
  #if defined(_M_IX86) || defined(_M_X64)
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((((const unsigned char*)EnableBits)[BitPosition >> 3] & (1u << (BitPosition & 7))) != 0)
  #else // CPU type
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((EnableBits[BitPosition >> 5] & (1u << (BitPosition & 31))) != 0)
  #endif // CPU type
#endif // _mcgen_EVENT_BIT_SET

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Valve-Main" event count 14
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 3fa9201e-73b0-43fe-9821-7e145359bc6f
EXTERN_C __declspec(selectany) const GUID VALVE_MAIN = {0x3fa9201e, 0x73b0, 0x43fe, {0x98, 0x21, 0x7e, 0x14, 0x53, 0x59, 0xbc, 0x6f}};

#ifndef VALVE_MAIN_Traits
#define VALVE_MAIN_Traits NULL
#endif // VALVE_MAIN_Traits

//
// Opcodes
//
#define _BeginOpcode 0xa
#define _EndOpcode 0xb
#define _StepOpcode 0xc
#define _MarkOpcode 0xd
#define _MarkOpcode1F 0xe
#define _MarkOpcode2F 0xf
#define _MarkOpcode3F 0x10
#define _MarkOpcode4F 0x11
#define _MarkOpcode1I 0x12
#define _MarkOpcode2I 0x13
#define _MarkOpcode3I 0x14
#define _MarkOpcode4I 0x15
#define _MarkOpcode1S 0x16
#define _MarkOpcode2S 0x17
#define _InformationOpcode 0x18

//
// Tasks
//
#define Block_Task 0x1
EXTERN_C __declspec(selectany) const GUID BlockId = {0xf15f363a, 0x49fd, 0x4de3, {0x96, 0x7c, 0x17, 0x32, 0x46, 0x49, 0x45, 0xff}};
#define ThreadID_Task 0x2
EXTERN_C __declspec(selectany) const GUID ThreadIDId = {0xf15f363a, 0x493d, 0x4dea, {0x96, 0x7c, 0x11, 0x23, 0x46, 0x49, 0x45, 0xff}};

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Start = {0x64, 0x0, 0x0, 0x0, 0xa, 0x1, 0x0};
#define Start_value 0x64
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Stop = {0x65, 0x0, 0x0, 0x0, 0xb, 0x1, 0x0};
#define Stop_value 0x65
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark = {0x66, 0x0, 0x0, 0x0, 0xd, 0x1, 0x0};
#define Mark_value 0x66
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark1F = {0x67, 0x0, 0x0, 0x0, 0xe, 0x1, 0x0};
#define Mark1F_value 0x67
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark2F = {0x68, 0x0, 0x0, 0x0, 0xf, 0x1, 0x0};
#define Mark2F_value 0x68
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark3F = {0x69, 0x0, 0x0, 0x0, 0x10, 0x1, 0x0};
#define Mark3F_value 0x69
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark4F = {0x6a, 0x0, 0x0, 0x0, 0x11, 0x1, 0x0};
#define Mark4F_value 0x6a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark1I = {0x6b, 0x0, 0x0, 0x0, 0x12, 0x1, 0x0};
#define Mark1I_value 0x6b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark2I = {0x6c, 0x0, 0x0, 0x0, 0x13, 0x1, 0x0};
#define Mark2I_value 0x6c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark3I = {0x6d, 0x0, 0x0, 0x0, 0x14, 0x1, 0x0};
#define Mark3I_value 0x6d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark4I = {0x6e, 0x0, 0x0, 0x0, 0x15, 0x1, 0x0};
#define Mark4I_value 0x6e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark1S = {0x6f, 0x0, 0x0, 0x0, 0x16, 0x1, 0x0};
#define Mark1S_value 0x6f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark2S = {0x70, 0x0, 0x0, 0x0, 0x17, 0x1, 0x0};
#define Mark2S_value 0x70
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Thread_ID = {0x71, 0x0, 0x0, 0x4, 0x18, 0x2, 0x0};
#define Thread_ID_value 0x71

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Valve_MainEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Valve_MainKeywords[2] = {0x0, 0x0};
EXTERN_C __declspec(selectany) const unsigned char Valve_MainLevels[2] = {0, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT VALVE_MAIN_Context = {0, (ULONG_PTR)VALVE_MAIN_Traits, 0, 0, 0, 0, 0, 0, 2, Valve_MainEnableBits, Valve_MainKeywords, Valve_MainLevels};

//
// Provider REGHANDLE
//
#define Valve_MainHandle (VALVE_MAIN_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define VALVE_MAIN_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterValve_Main
#define EventRegisterValve_Main() McGenEventRegister(&VALVE_MAIN, McGenControlCallbackV2, &VALVE_MAIN_Context, &Valve_MainHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidValve_Main
#define EventRegisterByGuidValve_Main(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &VALVE_MAIN_Context, &Valve_MainHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterValve_Main
#define EventUnregisterValve_Main() McGenEventUnregister(&Valve_MainHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Valve_Main));
// - Caller registers the provider, e.g. EventRegisterValve_Main_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterValve_Main_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Valve_Main {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Valve_MainHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Valve_Main;

#define EventRegisterValve_Main_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Main_, MCGEN_EVENTREGISTER)(&VALVE_MAIN, pContext)
#define EventRegisterByGuidValve_Main_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Main_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterValve_Main_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Valve_MainHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Main_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Valve_Main* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)VALVE_MAIN_Traits;
    pContext->Context.EnableBitsCount = 2;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Valve_MainKeywords;
    pContext->Context.EnableLevel = Valve_MainLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Valve_Main*
_mcgen_CheckContextType_Valve_Main(_In_ McGenContext_Valve_Main* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "Start"
//
#define EventEnabledStart() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Start"
//
#define EventWriteStart(Description, Depth) \
        MCGEN_EVENT_ENABLED(Start) \
        ? _mcgen_TEMPLATE_FOR_Start(&VALVE_MAIN_Context, &Start, Description, Depth) : 0
#define EventWriteStart_AssumeEnabled(Description, Depth) \
        _mcgen_TEMPLATE_FOR_Start(&VALVE_MAIN_Context, &Start, Description, Depth)
#define EventWriteStart_ForContext(pContext, Description, Depth) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Start) \
        ? _mcgen_TEMPLATE_FOR_Start(&(pContext)->Context, &Start, Description, Depth) : 0
#define EventWriteStart_ForContextAssumeEnabled(pContext, Description, Depth) \
        _mcgen_TEMPLATE_FOR_Start(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Start, Description, Depth)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Start _mcgen_PASTE2(McTemplateU0sd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Stop"
//
#define EventEnabledStop() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Stop"
//
#define EventWriteStop(Description, Depth, Duration__ms_) \
        MCGEN_EVENT_ENABLED(Stop) \
        ? _mcgen_TEMPLATE_FOR_Stop(&VALVE_MAIN_Context, &Stop, Description, Depth, Duration__ms_) : 0
#define EventWriteStop_AssumeEnabled(Description, Depth, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_Stop(&VALVE_MAIN_Context, &Stop, Description, Depth, Duration__ms_)
#define EventWriteStop_ForContext(pContext, Description, Depth, Duration__ms_) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Stop) \
        ? _mcgen_TEMPLATE_FOR_Stop(&(pContext)->Context, &Stop, Description, Depth, Duration__ms_) : 0
#define EventWriteStop_ForContextAssumeEnabled(pContext, Description, Depth, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_Stop(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Stop, Description, Depth, Duration__ms_)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Stop _mcgen_PASTE2(McTemplateU0sdf_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark"
//
#define EventEnabledMark() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark"
//
#define EventWriteMark(Description) \
        MCGEN_EVENT_ENABLED(Mark) \
        ? _mcgen_TEMPLATE_FOR_Mark(&VALVE_MAIN_Context, &Mark, Description) : 0
#define EventWriteMark_AssumeEnabled(Description) \
        _mcgen_TEMPLATE_FOR_Mark(&VALVE_MAIN_Context, &Mark, Description)
#define EventWriteMark_ForContext(pContext, Description) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark) \
        ? _mcgen_TEMPLATE_FOR_Mark(&(pContext)->Context, &Mark, Description) : 0
#define EventWriteMark_ForContextAssumeEnabled(pContext, Description) \
        _mcgen_TEMPLATE_FOR_Mark(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark, Description)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark _mcgen_PASTE2(McTemplateU0s_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark1F"
//
#define EventEnabledMark1F() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark1F_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark1F"
//
#define EventWriteMark1F(Description, Data_1) \
        MCGEN_EVENT_ENABLED(Mark1F) \
        ? _mcgen_TEMPLATE_FOR_Mark1F(&VALVE_MAIN_Context, &Mark1F, Description, Data_1) : 0
#define EventWriteMark1F_AssumeEnabled(Description, Data_1) \
        _mcgen_TEMPLATE_FOR_Mark1F(&VALVE_MAIN_Context, &Mark1F, Description, Data_1)
#define EventWriteMark1F_ForContext(pContext, Description, Data_1) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark1F) \
        ? _mcgen_TEMPLATE_FOR_Mark1F(&(pContext)->Context, &Mark1F, Description, Data_1) : 0
#define EventWriteMark1F_ForContextAssumeEnabled(pContext, Description, Data_1) \
        _mcgen_TEMPLATE_FOR_Mark1F(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark1F, Description, Data_1)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark1F _mcgen_PASTE2(McTemplateU0sf_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark2F"
//
#define EventEnabledMark2F() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark2F_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark2F"
//
#define EventWriteMark2F(Description, Data_1, Data_2) \
        MCGEN_EVENT_ENABLED(Mark2F) \
        ? _mcgen_TEMPLATE_FOR_Mark2F(&VALVE_MAIN_Context, &Mark2F, Description, Data_1, Data_2) : 0
#define EventWriteMark2F_AssumeEnabled(Description, Data_1, Data_2) \
        _mcgen_TEMPLATE_FOR_Mark2F(&VALVE_MAIN_Context, &Mark2F, Description, Data_1, Data_2)
#define EventWriteMark2F_ForContext(pContext, Description, Data_1, Data_2) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark2F) \
        ? _mcgen_TEMPLATE_FOR_Mark2F(&(pContext)->Context, &Mark2F, Description, Data_1, Data_2) : 0
#define EventWriteMark2F_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2) \
        _mcgen_TEMPLATE_FOR_Mark2F(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark2F, Description, Data_1, Data_2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark2F _mcgen_PASTE2(McTemplateU0sff_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark3F"
//
#define EventEnabledMark3F() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark3F_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark3F"
//
#define EventWriteMark3F(Description, Data_1, Data_2, Data_3) \
        MCGEN_EVENT_ENABLED(Mark3F) \
        ? _mcgen_TEMPLATE_FOR_Mark3F(&VALVE_MAIN_Context, &Mark3F, Description, Data_1, Data_2, Data_3) : 0
#define EventWriteMark3F_AssumeEnabled(Description, Data_1, Data_2, Data_3) \
        _mcgen_TEMPLATE_FOR_Mark3F(&VALVE_MAIN_Context, &Mark3F, Description, Data_1, Data_2, Data_3)
#define EventWriteMark3F_ForContext(pContext, Description, Data_1, Data_2, Data_3) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark3F) \
        ? _mcgen_TEMPLATE_FOR_Mark3F(&(pContext)->Context, &Mark3F, Description, Data_1, Data_2, Data_3) : 0
#define EventWriteMark3F_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2, Data_3) \
        _mcgen_TEMPLATE_FOR_Mark3F(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark3F, Description, Data_1, Data_2, Data_3)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark3F _mcgen_PASTE2(McTemplateU0sfff_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark4F"
//
#define EventEnabledMark4F() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark4F_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark4F"
//
#define EventWriteMark4F(Description, Data_1, Data_2, Data_3, Data_4) \
        MCGEN_EVENT_ENABLED(Mark4F) \
        ? _mcgen_TEMPLATE_FOR_Mark4F(&VALVE_MAIN_Context, &Mark4F, Description, Data_1, Data_2, Data_3, Data_4) : 0
#define EventWriteMark4F_AssumeEnabled(Description, Data_1, Data_2, Data_3, Data_4) \
        _mcgen_TEMPLATE_FOR_Mark4F(&VALVE_MAIN_Context, &Mark4F, Description, Data_1, Data_2, Data_3, Data_4)
#define EventWriteMark4F_ForContext(pContext, Description, Data_1, Data_2, Data_3, Data_4) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark4F) \
        ? _mcgen_TEMPLATE_FOR_Mark4F(&(pContext)->Context, &Mark4F, Description, Data_1, Data_2, Data_3, Data_4) : 0
#define EventWriteMark4F_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2, Data_3, Data_4) \
        _mcgen_TEMPLATE_FOR_Mark4F(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark4F, Description, Data_1, Data_2, Data_3, Data_4)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark4F _mcgen_PASTE2(McTemplateU0sffff_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark1I"
//
#define EventEnabledMark1I() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark1I_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark1I"
//
#define EventWriteMark1I(Description, Data_1) \
        MCGEN_EVENT_ENABLED(Mark1I) \
        ? _mcgen_TEMPLATE_FOR_Mark1I(&VALVE_MAIN_Context, &Mark1I, Description, Data_1) : 0
#define EventWriteMark1I_AssumeEnabled(Description, Data_1) \
        _mcgen_TEMPLATE_FOR_Mark1I(&VALVE_MAIN_Context, &Mark1I, Description, Data_1)
#define EventWriteMark1I_ForContext(pContext, Description, Data_1) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark1I) \
        ? _mcgen_TEMPLATE_FOR_Mark1I(&(pContext)->Context, &Mark1I, Description, Data_1) : 0
#define EventWriteMark1I_ForContextAssumeEnabled(pContext, Description, Data_1) \
        _mcgen_TEMPLATE_FOR_Mark1I(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark1I, Description, Data_1)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark1I _mcgen_PASTE2(McTemplateU0sd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark2I"
//
#define EventEnabledMark2I() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark2I_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark2I"
//
#define EventWriteMark2I(Description, Data_1, Data_2) \
        MCGEN_EVENT_ENABLED(Mark2I) \
        ? _mcgen_TEMPLATE_FOR_Mark2I(&VALVE_MAIN_Context, &Mark2I, Description, Data_1, Data_2) : 0
#define EventWriteMark2I_AssumeEnabled(Description, Data_1, Data_2) \
        _mcgen_TEMPLATE_FOR_Mark2I(&VALVE_MAIN_Context, &Mark2I, Description, Data_1, Data_2)
#define EventWriteMark2I_ForContext(pContext, Description, Data_1, Data_2) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark2I) \
        ? _mcgen_TEMPLATE_FOR_Mark2I(&(pContext)->Context, &Mark2I, Description, Data_1, Data_2) : 0
#define EventWriteMark2I_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2) \
        _mcgen_TEMPLATE_FOR_Mark2I(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark2I, Description, Data_1, Data_2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark2I _mcgen_PASTE2(McTemplateU0sdd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark3I"
//
#define EventEnabledMark3I() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark3I_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark3I"
//
#define EventWriteMark3I(Description, Data_1, Data_2, Data_3) \
        MCGEN_EVENT_ENABLED(Mark3I) \
        ? _mcgen_TEMPLATE_FOR_Mark3I(&VALVE_MAIN_Context, &Mark3I, Description, Data_1, Data_2, Data_3) : 0
#define EventWriteMark3I_AssumeEnabled(Description, Data_1, Data_2, Data_3) \
        _mcgen_TEMPLATE_FOR_Mark3I(&VALVE_MAIN_Context, &Mark3I, Description, Data_1, Data_2, Data_3)
#define EventWriteMark3I_ForContext(pContext, Description, Data_1, Data_2, Data_3) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark3I) \
        ? _mcgen_TEMPLATE_FOR_Mark3I(&(pContext)->Context, &Mark3I, Description, Data_1, Data_2, Data_3) : 0
#define EventWriteMark3I_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2, Data_3) \
        _mcgen_TEMPLATE_FOR_Mark3I(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark3I, Description, Data_1, Data_2, Data_3)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark3I _mcgen_PASTE2(McTemplateU0sddd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark4I"
//
#define EventEnabledMark4I() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark4I_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark4I"
//
#define EventWriteMark4I(Description, Data_1, Data_2, Data_3, Data_4) \
        MCGEN_EVENT_ENABLED(Mark4I) \
        ? _mcgen_TEMPLATE_FOR_Mark4I(&VALVE_MAIN_Context, &Mark4I, Description, Data_1, Data_2, Data_3, Data_4) : 0
#define EventWriteMark4I_AssumeEnabled(Description, Data_1, Data_2, Data_3, Data_4) \
        _mcgen_TEMPLATE_FOR_Mark4I(&VALVE_MAIN_Context, &Mark4I, Description, Data_1, Data_2, Data_3, Data_4)
#define EventWriteMark4I_ForContext(pContext, Description, Data_1, Data_2, Data_3, Data_4) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark4I) \
        ? _mcgen_TEMPLATE_FOR_Mark4I(&(pContext)->Context, &Mark4I, Description, Data_1, Data_2, Data_3, Data_4) : 0
#define EventWriteMark4I_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2, Data_3, Data_4) \
        _mcgen_TEMPLATE_FOR_Mark4I(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark4I, Description, Data_1, Data_2, Data_3, Data_4)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark4I _mcgen_PASTE2(McTemplateU0sdddd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark1S"
//
#define EventEnabledMark1S() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark1S_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark1S"
//
#define EventWriteMark1S(Description, Data_1) \
        MCGEN_EVENT_ENABLED(Mark1S) \
        ? _mcgen_TEMPLATE_FOR_Mark1S(&VALVE_MAIN_Context, &Mark1S, Description, Data_1) : 0
#define EventWriteMark1S_AssumeEnabled(Description, Data_1) \
        _mcgen_TEMPLATE_FOR_Mark1S(&VALVE_MAIN_Context, &Mark1S, Description, Data_1)
#define EventWriteMark1S_ForContext(pContext, Description, Data_1) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark1S) \
        ? _mcgen_TEMPLATE_FOR_Mark1S(&(pContext)->Context, &Mark1S, Description, Data_1) : 0
#define EventWriteMark1S_ForContextAssumeEnabled(pContext, Description, Data_1) \
        _mcgen_TEMPLATE_FOR_Mark1S(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark1S, Description, Data_1)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark1S _mcgen_PASTE2(McTemplateU0ss_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mark2S"
//
#define EventEnabledMark2S() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 0)
#define EventEnabledMark2S_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 0)

//
// Event write macros for event "Mark2S"
//
#define EventWriteMark2S(Description, Data_1, Data_2) \
        MCGEN_EVENT_ENABLED(Mark2S) \
        ? _mcgen_TEMPLATE_FOR_Mark2S(&VALVE_MAIN_Context, &Mark2S, Description, Data_1, Data_2) : 0
#define EventWriteMark2S_AssumeEnabled(Description, Data_1, Data_2) \
        _mcgen_TEMPLATE_FOR_Mark2S(&VALVE_MAIN_Context, &Mark2S, Description, Data_1, Data_2)
#define EventWriteMark2S_ForContext(pContext, Description, Data_1, Data_2) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mark2S) \
        ? _mcgen_TEMPLATE_FOR_Mark2S(&(pContext)->Context, &Mark2S, Description, Data_1, Data_2) : 0
#define EventWriteMark2S_ForContextAssumeEnabled(pContext, Description, Data_1, Data_2) \
        _mcgen_TEMPLATE_FOR_Mark2S(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Mark2S, Description, Data_1, Data_2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mark2S _mcgen_PASTE2(McTemplateU0sss_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Thread_ID"
//
#define EventEnabledThread_ID() _mcgen_EVENT_BIT_SET(Valve_MainEnableBits, 1)
#define EventEnabledThread_ID_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Main(pContext)->EnableBits, 1)

//
// Event write macros for event "Thread_ID"
//
#define EventWriteThread_ID(ThreadID, ThreadName) \
        MCGEN_EVENT_ENABLED(Thread_ID) \
        ? _mcgen_TEMPLATE_FOR_Thread_ID(&VALVE_MAIN_Context, &Thread_ID, ThreadID, ThreadName) : 0
#define EventWriteThread_ID_AssumeEnabled(ThreadID, ThreadName) \
        _mcgen_TEMPLATE_FOR_Thread_ID(&VALVE_MAIN_Context, &Thread_ID, ThreadID, ThreadName)
#define EventWriteThread_ID_ForContext(pContext, ThreadID, ThreadName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Thread_ID) \
        ? _mcgen_TEMPLATE_FOR_Thread_ID(&(pContext)->Context, &Thread_ID, ThreadID, ThreadName) : 0
#define EventWriteThread_ID_ForContextAssumeEnabled(pContext, ThreadID, ThreadName) \
        _mcgen_TEMPLATE_FOR_Thread_ID(&_mcgen_CheckContextType_Valve_Main(pContext)->Context, &Thread_ID, ThreadID, ThreadName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Thread_ID _mcgen_PASTE2(McTemplateU0ds_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Valve-FrameRate" event count 2
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 47a9201e-73b0-42ce-9821-7e134361bc6f
EXTERN_C __declspec(selectany) const GUID VALVE_FRAMERATE = {0x47a9201e, 0x73b0, 0x42ce, {0x98, 0x21, 0x7e, 0x13, 0x43, 0x61, 0xbc, 0x6f}};

#ifndef VALVE_FRAMERATE_Traits
#define VALVE_FRAMERATE_Traits NULL
#endif // VALVE_FRAMERATE_Traits

//
// Opcodes
//
#define _RenderFrameMarkOpcode 0xa
#define _SimFrameMarkOpcode 0xb

//
// Tasks
//
#define Frame_Task 0x1
EXTERN_C __declspec(selectany) const GUID FrameId = {0xf15f363a, 0x49fd, 0x4ffa, {0x96, 0x7c, 0x17, 0x39, 0x36, 0x49, 0x45, 0xff}};

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RenderFrameMark = {0xc8, 0x0, 0x0, 0x0, 0xa, 0x1, 0x0};
#define RenderFrameMark_value 0xc8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SimFrameMark = {0xc9, 0x0, 0x0, 0x0, 0xb, 0x1, 0x0};
#define SimFrameMark_value 0xc9

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Valve_FrameRateEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Valve_FrameRateKeywords[1] = {0x0};
EXTERN_C __declspec(selectany) const unsigned char Valve_FrameRateLevels[1] = {0};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT VALVE_FRAMERATE_Context = {0, (ULONG_PTR)VALVE_FRAMERATE_Traits, 0, 0, 0, 0, 0, 0, 1, Valve_FrameRateEnableBits, Valve_FrameRateKeywords, Valve_FrameRateLevels};

//
// Provider REGHANDLE
//
#define Valve_FrameRateHandle (VALVE_FRAMERATE_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define VALVE_FRAMERATE_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterValve_FrameRate
#define EventRegisterValve_FrameRate() McGenEventRegister(&VALVE_FRAMERATE, McGenControlCallbackV2, &VALVE_FRAMERATE_Context, &Valve_FrameRateHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidValve_FrameRate
#define EventRegisterByGuidValve_FrameRate(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &VALVE_FRAMERATE_Context, &Valve_FrameRateHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterValve_FrameRate
#define EventUnregisterValve_FrameRate() McGenEventUnregister(&Valve_FrameRateHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Valve_FrameRate));
// - Caller registers the provider, e.g. EventRegisterValve_FrameRate_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterValve_FrameRate_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Valve_FrameRate {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Valve_FrameRateHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Valve_FrameRate;

#define EventRegisterValve_FrameRate_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_FrameRate_, MCGEN_EVENTREGISTER)(&VALVE_FRAMERATE, pContext)
#define EventRegisterByGuidValve_FrameRate_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_FrameRate_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterValve_FrameRate_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Valve_FrameRateHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Valve_FrameRate_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Valve_FrameRate* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)VALVE_FRAMERATE_Traits;
    pContext->Context.EnableBitsCount = 1;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Valve_FrameRateKeywords;
    pContext->Context.EnableLevel = Valve_FrameRateLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Valve_FrameRate*
_mcgen_CheckContextType_Valve_FrameRate(_In_ McGenContext_Valve_FrameRate* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "RenderFrameMark"
//
#define EventEnabledRenderFrameMark() _mcgen_EVENT_BIT_SET(Valve_FrameRateEnableBits, 0)
#define EventEnabledRenderFrameMark_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_FrameRate(pContext)->EnableBits, 0)

//
// Event write macros for event "RenderFrameMark"
//
#define EventWriteRenderFrameMark(Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED(RenderFrameMark) \
        ? _mcgen_TEMPLATE_FOR_RenderFrameMark(&VALVE_FRAMERATE_Context, &RenderFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteRenderFrameMark_AssumeEnabled(Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_RenderFrameMark(&VALVE_FRAMERATE_Context, &RenderFrameMark, Frame_number, Duration__ms_)
#define EventWriteRenderFrameMark_ForContext(pContext, Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RenderFrameMark) \
        ? _mcgen_TEMPLATE_FOR_RenderFrameMark(&(pContext)->Context, &RenderFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteRenderFrameMark_ForContextAssumeEnabled(pContext, Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_RenderFrameMark(&_mcgen_CheckContextType_Valve_FrameRate(pContext)->Context, &RenderFrameMark, Frame_number, Duration__ms_)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RenderFrameMark _mcgen_PASTE2(McTemplateU0df_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SimFrameMark"
//
#define EventEnabledSimFrameMark() _mcgen_EVENT_BIT_SET(Valve_FrameRateEnableBits, 0)
#define EventEnabledSimFrameMark_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_FrameRate(pContext)->EnableBits, 0)

//
// Event write macros for event "SimFrameMark"
//
#define EventWriteSimFrameMark(Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED(SimFrameMark) \
        ? _mcgen_TEMPLATE_FOR_SimFrameMark(&VALVE_FRAMERATE_Context, &SimFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteSimFrameMark_AssumeEnabled(Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_SimFrameMark(&VALVE_FRAMERATE_Context, &SimFrameMark, Frame_number, Duration__ms_)
#define EventWriteSimFrameMark_ForContext(pContext, Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SimFrameMark) \
        ? _mcgen_TEMPLATE_FOR_SimFrameMark(&(pContext)->Context, &SimFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteSimFrameMark_ForContextAssumeEnabled(pContext, Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_SimFrameMark(&_mcgen_CheckContextType_Valve_FrameRate(pContext)->Context, &SimFrameMark, Frame_number, Duration__ms_)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SimFrameMark _mcgen_PASTE2(McTemplateU0df_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Valve-ServerFrameRate" event count 2
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 58a9201e-73b0-42ce-9821-7e134361bc70
EXTERN_C __declspec(selectany) const GUID VALVE_SERVERFRAMERATE = {0x58a9201e, 0x73b0, 0x42ce, {0x98, 0x21, 0x7e, 0x13, 0x43, 0x61, 0xbc, 0x70}};

#ifndef VALVE_SERVERFRAMERATE_Traits
#define VALVE_SERVERFRAMERATE_Traits NULL
#endif // VALVE_SERVERFRAMERATE_Traits

//
// Opcodes
//
#define _ServerRenderFrameMarkOpcode 0xa
#define _ServerSimFrameMarkOpcode 0xb

//
// Tasks
//
#define Frame_Task 0x1
EXTERN_C __declspec(selectany) const GUID ServerFrameId = {0x025f363a, 0x49fd, 0x4ffa, {0x96, 0x7c, 0x17, 0x39, 0x36, 0x49, 0x45, 0x00}};

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ServerRenderFrameMark = {0x12c, 0x0, 0x0, 0x0, 0xa, 0x1, 0x0};
#define ServerRenderFrameMark_value 0x12c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ServerSimFrameMark = {0x12d, 0x0, 0x0, 0x0, 0xb, 0x1, 0x0};
#define ServerSimFrameMark_value 0x12d

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Valve_ServerFrameRateEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Valve_ServerFrameRateKeywords[1] = {0x0};
EXTERN_C __declspec(selectany) const unsigned char Valve_ServerFrameRateLevels[1] = {0};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT VALVE_SERVERFRAMERATE_Context = {0, (ULONG_PTR)VALVE_SERVERFRAMERATE_Traits, 0, 0, 0, 0, 0, 0, 1, Valve_ServerFrameRateEnableBits, Valve_ServerFrameRateKeywords, Valve_ServerFrameRateLevels};

//
// Provider REGHANDLE
//
#define Valve_ServerFrameRateHandle (VALVE_SERVERFRAMERATE_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define VALVE_SERVERFRAMERATE_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterValve_ServerFrameRate
#define EventRegisterValve_ServerFrameRate() McGenEventRegister(&VALVE_SERVERFRAMERATE, McGenControlCallbackV2, &VALVE_SERVERFRAMERATE_Context, &Valve_ServerFrameRateHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidValve_ServerFrameRate
#define EventRegisterByGuidValve_ServerFrameRate(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &VALVE_SERVERFRAMERATE_Context, &Valve_ServerFrameRateHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterValve_ServerFrameRate
#define EventUnregisterValve_ServerFrameRate() McGenEventUnregister(&Valve_ServerFrameRateHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Valve_ServerFrameRate));
// - Caller registers the provider, e.g. EventRegisterValve_ServerFrameRate_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterValve_ServerFrameRate_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Valve_ServerFrameRate {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Valve_ServerFrameRateHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Valve_ServerFrameRate;

#define EventRegisterValve_ServerFrameRate_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_ServerFrameRate_, MCGEN_EVENTREGISTER)(&VALVE_SERVERFRAMERATE, pContext)
#define EventRegisterByGuidValve_ServerFrameRate_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_ServerFrameRate_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterValve_ServerFrameRate_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Valve_ServerFrameRateHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Valve_ServerFrameRate_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Valve_ServerFrameRate* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)VALVE_SERVERFRAMERATE_Traits;
    pContext->Context.EnableBitsCount = 1;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Valve_ServerFrameRateKeywords;
    pContext->Context.EnableLevel = Valve_ServerFrameRateLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Valve_ServerFrameRate*
_mcgen_CheckContextType_Valve_ServerFrameRate(_In_ McGenContext_Valve_ServerFrameRate* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "ServerRenderFrameMark"
//
#define EventEnabledServerRenderFrameMark() _mcgen_EVENT_BIT_SET(Valve_ServerFrameRateEnableBits, 0)
#define EventEnabledServerRenderFrameMark_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_ServerFrameRate(pContext)->EnableBits, 0)

//
// Event write macros for event "ServerRenderFrameMark"
//
#define EventWriteServerRenderFrameMark(Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED(ServerRenderFrameMark) \
        ? _mcgen_TEMPLATE_FOR_ServerRenderFrameMark(&VALVE_SERVERFRAMERATE_Context, &ServerRenderFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteServerRenderFrameMark_AssumeEnabled(Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_ServerRenderFrameMark(&VALVE_SERVERFRAMERATE_Context, &ServerRenderFrameMark, Frame_number, Duration__ms_)
#define EventWriteServerRenderFrameMark_ForContext(pContext, Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ServerRenderFrameMark) \
        ? _mcgen_TEMPLATE_FOR_ServerRenderFrameMark(&(pContext)->Context, &ServerRenderFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteServerRenderFrameMark_ForContextAssumeEnabled(pContext, Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_ServerRenderFrameMark(&_mcgen_CheckContextType_Valve_ServerFrameRate(pContext)->Context, &ServerRenderFrameMark, Frame_number, Duration__ms_)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ServerRenderFrameMark _mcgen_PASTE2(McTemplateU0df_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ServerSimFrameMark"
//
#define EventEnabledServerSimFrameMark() _mcgen_EVENT_BIT_SET(Valve_ServerFrameRateEnableBits, 0)
#define EventEnabledServerSimFrameMark_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_ServerFrameRate(pContext)->EnableBits, 0)

//
// Event write macros for event "ServerSimFrameMark"
//
#define EventWriteServerSimFrameMark(Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED(ServerSimFrameMark) \
        ? _mcgen_TEMPLATE_FOR_ServerSimFrameMark(&VALVE_SERVERFRAMERATE_Context, &ServerSimFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteServerSimFrameMark_AssumeEnabled(Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_ServerSimFrameMark(&VALVE_SERVERFRAMERATE_Context, &ServerSimFrameMark, Frame_number, Duration__ms_)
#define EventWriteServerSimFrameMark_ForContext(pContext, Frame_number, Duration__ms_) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ServerSimFrameMark) \
        ? _mcgen_TEMPLATE_FOR_ServerSimFrameMark(&(pContext)->Context, &ServerSimFrameMark, Frame_number, Duration__ms_) : 0
#define EventWriteServerSimFrameMark_ForContextAssumeEnabled(pContext, Frame_number, Duration__ms_) \
        _mcgen_TEMPLATE_FOR_ServerSimFrameMark(&_mcgen_CheckContextType_Valve_ServerFrameRate(pContext)->Context, &ServerSimFrameMark, Frame_number, Duration__ms_)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ServerSimFrameMark _mcgen_PASTE2(McTemplateU0df_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Valve-Input" event count 5
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 1432afee-73b0-42ce-9821-7e134361b433
EXTERN_C __declspec(selectany) const GUID VALVE_INPUT = {0x1432afee, 0x73b0, 0x42ce, {0x98, 0x21, 0x7e, 0x13, 0x43, 0x61, 0xb4, 0x33}};

#ifndef VALVE_INPUT_Traits
#define VALVE_INPUT_Traits NULL
#endif // VALVE_INPUT_Traits

//
// Opcodes
//
#define _MouseDownOpcode 0xa
#define _MouseUpOpcode 0xb
#define _KeyDownOpcode 0xc
#define _MouseMoveOpcode 0xd
#define _MouseWheelOpcode 0xe

//
// Tasks
//
#define Mouse_Task 0x1
EXTERN_C __declspec(selectany) const GUID MouseId = {0x363a49fd, 0xf15f, 0x4ffa, {0x96, 0x7c, 0x17, 0x39, 0x36, 0x49, 0x44, 0x33}};
#define Keyboard_Task 0x2
EXTERN_C __declspec(selectany) const GUID KeyboardId = {0x123a49fd, 0xf15f, 0x4ffa, {0x96, 0x7c, 0x17, 0x39, 0x36, 0x49, 0xbe, 0xad}};

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_down = {0x190, 0x0, 0x0, 0x0, 0xa, 0x1, 0x0};
#define Mouse_down_value 0x190
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_up = {0x191, 0x0, 0x0, 0x0, 0xb, 0x1, 0x0};
#define Mouse_up_value 0x191
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Key_down = {0x192, 0x0, 0x0, 0x0, 0xc, 0x2, 0x0};
#define Key_down_value 0x192
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_Move = {0x193, 0x0, 0x0, 0x0, 0xd, 0x1, 0x0};
#define Mouse_Move_value 0x193
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_Wheel = {0x194, 0x0, 0x0, 0x0, 0xe, 0x1, 0x0};
#define Mouse_Wheel_value 0x194

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Valve_InputEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Valve_InputKeywords[1] = {0x0};
EXTERN_C __declspec(selectany) const unsigned char Valve_InputLevels[1] = {0};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT VALVE_INPUT_Context = {0, (ULONG_PTR)VALVE_INPUT_Traits, 0, 0, 0, 0, 0, 0, 1, Valve_InputEnableBits, Valve_InputKeywords, Valve_InputLevels};

//
// Provider REGHANDLE
//
#define Valve_InputHandle (VALVE_INPUT_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define VALVE_INPUT_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterValve_Input
#define EventRegisterValve_Input() McGenEventRegister(&VALVE_INPUT, McGenControlCallbackV2, &VALVE_INPUT_Context, &Valve_InputHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidValve_Input
#define EventRegisterByGuidValve_Input(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &VALVE_INPUT_Context, &Valve_InputHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterValve_Input
#define EventUnregisterValve_Input() McGenEventUnregister(&Valve_InputHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Valve_Input));
// - Caller registers the provider, e.g. EventRegisterValve_Input_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterValve_Input_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Valve_Input {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Valve_InputHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Valve_Input;

#define EventRegisterValve_Input_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Input_, MCGEN_EVENTREGISTER)(&VALVE_INPUT, pContext)
#define EventRegisterByGuidValve_Input_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Input_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterValve_Input_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Valve_InputHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Input_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Valve_Input* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)VALVE_INPUT_Traits;
    pContext->Context.EnableBitsCount = 1;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Valve_InputKeywords;
    pContext->Context.EnableLevel = Valve_InputLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Valve_Input*
_mcgen_CheckContextType_Valve_Input(_In_ McGenContext_Valve_Input* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "Mouse_down"
//
#define EventEnabledMouse_down() _mcgen_EVENT_BIT_SET(Valve_InputEnableBits, 0)
#define EventEnabledMouse_down_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Input(pContext)->EnableBits, 0)

//
// Event write macros for event "Mouse_down"
//
#define EventWriteMouse_down(x, y, Button_Type) \
        MCGEN_EVENT_ENABLED(Mouse_down) \
        ? _mcgen_TEMPLATE_FOR_Mouse_down(&VALVE_INPUT_Context, &Mouse_down, x, y, Button_Type) : 0
#define EventWriteMouse_down_AssumeEnabled(x, y, Button_Type) \
        _mcgen_TEMPLATE_FOR_Mouse_down(&VALVE_INPUT_Context, &Mouse_down, x, y, Button_Type)
#define EventWriteMouse_down_ForContext(pContext, x, y, Button_Type) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mouse_down) \
        ? _mcgen_TEMPLATE_FOR_Mouse_down(&(pContext)->Context, &Mouse_down, x, y, Button_Type) : 0
#define EventWriteMouse_down_ForContextAssumeEnabled(pContext, x, y, Button_Type) \
        _mcgen_TEMPLATE_FOR_Mouse_down(&_mcgen_CheckContextType_Valve_Input(pContext)->Context, &Mouse_down, x, y, Button_Type)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mouse_down _mcgen_PASTE2(McTemplateU0ddd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mouse_up"
//
#define EventEnabledMouse_up() _mcgen_EVENT_BIT_SET(Valve_InputEnableBits, 0)
#define EventEnabledMouse_up_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Input(pContext)->EnableBits, 0)

//
// Event write macros for event "Mouse_up"
//
#define EventWriteMouse_up(x, y, Button_Type) \
        MCGEN_EVENT_ENABLED(Mouse_up) \
        ? _mcgen_TEMPLATE_FOR_Mouse_up(&VALVE_INPUT_Context, &Mouse_up, x, y, Button_Type) : 0
#define EventWriteMouse_up_AssumeEnabled(x, y, Button_Type) \
        _mcgen_TEMPLATE_FOR_Mouse_up(&VALVE_INPUT_Context, &Mouse_up, x, y, Button_Type)
#define EventWriteMouse_up_ForContext(pContext, x, y, Button_Type) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mouse_up) \
        ? _mcgen_TEMPLATE_FOR_Mouse_up(&(pContext)->Context, &Mouse_up, x, y, Button_Type) : 0
#define EventWriteMouse_up_ForContextAssumeEnabled(pContext, x, y, Button_Type) \
        _mcgen_TEMPLATE_FOR_Mouse_up(&_mcgen_CheckContextType_Valve_Input(pContext)->Context, &Mouse_up, x, y, Button_Type)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mouse_up _mcgen_PASTE2(McTemplateU0ddd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Key_down"
//
#define EventEnabledKey_down() _mcgen_EVENT_BIT_SET(Valve_InputEnableBits, 0)
#define EventEnabledKey_down_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Input(pContext)->EnableBits, 0)

//
// Event write macros for event "Key_down"
//
#define EventWriteKey_down(Character, Scan_Code, Virtual_Code) \
        MCGEN_EVENT_ENABLED(Key_down) \
        ? _mcgen_TEMPLATE_FOR_Key_down(&VALVE_INPUT_Context, &Key_down, Character, Scan_Code, Virtual_Code) : 0
#define EventWriteKey_down_AssumeEnabled(Character, Scan_Code, Virtual_Code) \
        _mcgen_TEMPLATE_FOR_Key_down(&VALVE_INPUT_Context, &Key_down, Character, Scan_Code, Virtual_Code)
#define EventWriteKey_down_ForContext(pContext, Character, Scan_Code, Virtual_Code) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Key_down) \
        ? _mcgen_TEMPLATE_FOR_Key_down(&(pContext)->Context, &Key_down, Character, Scan_Code, Virtual_Code) : 0
#define EventWriteKey_down_ForContextAssumeEnabled(pContext, Character, Scan_Code, Virtual_Code) \
        _mcgen_TEMPLATE_FOR_Key_down(&_mcgen_CheckContextType_Valve_Input(pContext)->Context, &Key_down, Character, Scan_Code, Virtual_Code)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Key_down _mcgen_PASTE2(McTemplateU0sdd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mouse_Move"
//
#define EventEnabledMouse_Move() _mcgen_EVENT_BIT_SET(Valve_InputEnableBits, 0)
#define EventEnabledMouse_Move_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Input(pContext)->EnableBits, 0)

//
// Event write macros for event "Mouse_Move"
//
#define EventWriteMouse_Move(x, y) \
        MCGEN_EVENT_ENABLED(Mouse_Move) \
        ? _mcgen_TEMPLATE_FOR_Mouse_Move(&VALVE_INPUT_Context, &Mouse_Move, x, y) : 0
#define EventWriteMouse_Move_AssumeEnabled(x, y) \
        _mcgen_TEMPLATE_FOR_Mouse_Move(&VALVE_INPUT_Context, &Mouse_Move, x, y)
#define EventWriteMouse_Move_ForContext(pContext, x, y) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mouse_Move) \
        ? _mcgen_TEMPLATE_FOR_Mouse_Move(&(pContext)->Context, &Mouse_Move, x, y) : 0
#define EventWriteMouse_Move_ForContextAssumeEnabled(pContext, x, y) \
        _mcgen_TEMPLATE_FOR_Mouse_Move(&_mcgen_CheckContextType_Valve_Input(pContext)->Context, &Mouse_Move, x, y)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mouse_Move _mcgen_PASTE2(McTemplateU0dd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Mouse_Wheel"
//
#define EventEnabledMouse_Wheel() _mcgen_EVENT_BIT_SET(Valve_InputEnableBits, 0)
#define EventEnabledMouse_Wheel_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Input(pContext)->EnableBits, 0)

//
// Event write macros for event "Mouse_Wheel"
//
#define EventWriteMouse_Wheel(x, y, wheelDelta) \
        MCGEN_EVENT_ENABLED(Mouse_Wheel) \
        ? _mcgen_TEMPLATE_FOR_Mouse_Wheel(&VALVE_INPUT_Context, &Mouse_Wheel, x, y, wheelDelta) : 0
#define EventWriteMouse_Wheel_AssumeEnabled(x, y, wheelDelta) \
        _mcgen_TEMPLATE_FOR_Mouse_Wheel(&VALVE_INPUT_Context, &Mouse_Wheel, x, y, wheelDelta)
#define EventWriteMouse_Wheel_ForContext(pContext, x, y, wheelDelta) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Mouse_Wheel) \
        ? _mcgen_TEMPLATE_FOR_Mouse_Wheel(&(pContext)->Context, &Mouse_Wheel, x, y, wheelDelta) : 0
#define EventWriteMouse_Wheel_ForContextAssumeEnabled(pContext, x, y, wheelDelta) \
        _mcgen_TEMPLATE_FOR_Mouse_Wheel(&_mcgen_CheckContextType_Valve_Input(pContext)->Context, &Mouse_Wheel, x, y, wheelDelta)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Mouse_Wheel _mcgen_PASTE2(McTemplateU0ddd_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Valve-Network" event count 3
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = 4372afee-73b0-42ce-9821-7e134361b519
EXTERN_C __declspec(selectany) const GUID VALVE_NETWORK = {0x4372afee, 0x73b0, 0x42ce, {0x98, 0x21, 0x7e, 0x13, 0x43, 0x61, 0xb5, 0x19}};

#ifndef VALVE_NETWORK_Traits
#define VALVE_NETWORK_Traits NULL
#endif // VALVE_NETWORK_Traits

//
// Opcodes
//
#define _SendOpcode 0xa
#define _ThrottledOpcode 0xb
#define _ReadOpcode 0xc

//
// Tasks
//
#define Transmit_Task 0x1
EXTERN_C __declspec(selectany) const GUID TransmitId = {0x932a49fd, 0xf15f, 0x4ffa, {0x96, 0x7c, 0x17, 0x39, 0x36, 0x49, 0x49, 0x01}};
#define Network_Task 0x2
EXTERN_C __declspec(selectany) const GUID ThrottledId = {0xa32a49fd, 0xf15f, 0x4ffa, {0x96, 0x7c, 0x17, 0x39, 0x36, 0x49, 0x49, 0x02}};

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SendPacket = {0x1f4, 0x0, 0x0, 0x0, 0xa, 0x1, 0x0};
#define SendPacket_value 0x1f4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Throttled = {0x1f5, 0x0, 0x0, 0x0, 0xb, 0x2, 0x0};
#define Throttled_value 0x1f5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ReadPacket = {0x1f6, 0x0, 0x0, 0x0, 0xc, 0x1, 0x0};
#define ReadPacket_value 0x1f6

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Valve_NetworkEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Valve_NetworkKeywords[1] = {0x0};
EXTERN_C __declspec(selectany) const unsigned char Valve_NetworkLevels[1] = {0};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT VALVE_NETWORK_Context = {0, (ULONG_PTR)VALVE_NETWORK_Traits, 0, 0, 0, 0, 0, 0, 1, Valve_NetworkEnableBits, Valve_NetworkKeywords, Valve_NetworkLevels};

//
// Provider REGHANDLE
//
#define Valve_NetworkHandle (VALVE_NETWORK_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define VALVE_NETWORK_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterValve_Network
#define EventRegisterValve_Network() McGenEventRegister(&VALVE_NETWORK, McGenControlCallbackV2, &VALVE_NETWORK_Context, &Valve_NetworkHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidValve_Network
#define EventRegisterByGuidValve_Network(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &VALVE_NETWORK_Context, &Valve_NetworkHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterValve_Network
#define EventUnregisterValve_Network() McGenEventUnregister(&Valve_NetworkHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Valve_Network));
// - Caller registers the provider, e.g. EventRegisterValve_Network_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterValve_Network_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Valve_Network {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Valve_NetworkHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Valve_Network;

#define EventRegisterValve_Network_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Network_, MCGEN_EVENTREGISTER)(&VALVE_NETWORK, pContext)
#define EventRegisterByGuidValve_Network_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Network_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterValve_Network_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Valve_NetworkHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Valve_Network_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Valve_Network* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)VALVE_NETWORK_Traits;
    pContext->Context.EnableBitsCount = 1;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Valve_NetworkKeywords;
    pContext->Context.EnableLevel = Valve_NetworkLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Valve_Network*
_mcgen_CheckContextType_Valve_Network(_In_ McGenContext_Valve_Network* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "SendPacket"
//
#define EventEnabledSendPacket() _mcgen_EVENT_BIT_SET(Valve_NetworkEnableBits, 0)
#define EventEnabledSendPacket_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Network(pContext)->EnableBits, 0)

//
// Event write macros for event "SendPacket"
//
#define EventWriteSendPacket(To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        MCGEN_EVENT_ENABLED(SendPacket) \
        ? _mcgen_TEMPLATE_FOR_SendPacket(&VALVE_NETWORK_Context, &SendPacket, To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize) : 0
#define EventWriteSendPacket_AssumeEnabled(To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        _mcgen_TEMPLATE_FOR_SendPacket(&VALVE_NETWORK_Context, &SendPacket, To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize)
#define EventWriteSendPacket_ForContext(pContext, To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SendPacket) \
        ? _mcgen_TEMPLATE_FOR_SendPacket(&(pContext)->Context, &SendPacket, To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize) : 0
#define EventWriteSendPacket_ForContextAssumeEnabled(pContext, To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        _mcgen_TEMPLATE_FOR_SendPacket(&_mcgen_CheckContextType_Valve_Network(pContext)->Context, &SendPacket, To, WireSize, outSequenceNR, outSequenceNrAck, CumulativeWireSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SendPacket _mcgen_PASTE2(McTemplateU0sdddd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Throttled"
//
#define EventEnabledThrottled() _mcgen_EVENT_BIT_SET(Valve_NetworkEnableBits, 0)
#define EventEnabledThrottled_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Network(pContext)->EnableBits, 0)

//
// Event write macros for event "Throttled"
//
#define EventWriteThrottled() \
        MCGEN_EVENT_ENABLED(Throttled) \
        ? _mcgen_TEMPLATE_FOR_Throttled(&VALVE_NETWORK_Context, &Throttled) : 0
#define EventWriteThrottled_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_Throttled(&VALVE_NETWORK_Context, &Throttled)
#define EventWriteThrottled_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Throttled) \
        ? _mcgen_TEMPLATE_FOR_Throttled(&(pContext)->Context, &Throttled) : 0
#define EventWriteThrottled_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_Throttled(&_mcgen_CheckContextType_Valve_Network(pContext)->Context, &Throttled)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Throttled _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ReadPacket"
//
#define EventEnabledReadPacket() _mcgen_EVENT_BIT_SET(Valve_NetworkEnableBits, 0)
#define EventEnabledReadPacket_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Valve_Network(pContext)->EnableBits, 0)

//
// Event write macros for event "ReadPacket"
//
#define EventWriteReadPacket(From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        MCGEN_EVENT_ENABLED(ReadPacket) \
        ? _mcgen_TEMPLATE_FOR_ReadPacket(&VALVE_NETWORK_Context, &ReadPacket, From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize) : 0
#define EventWriteReadPacket_AssumeEnabled(From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        _mcgen_TEMPLATE_FOR_ReadPacket(&VALVE_NETWORK_Context, &ReadPacket, From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize)
#define EventWriteReadPacket_ForContext(pContext, From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ReadPacket) \
        ? _mcgen_TEMPLATE_FOR_ReadPacket(&(pContext)->Context, &ReadPacket, From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize) : 0
#define EventWriteReadPacket_ForContextAssumeEnabled(pContext, From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize) \
        _mcgen_TEMPLATE_FOR_ReadPacket(&_mcgen_CheckContextType_Valve_Network(pContext)->Context, &ReadPacket, From, WireSize, inSequenceNR, outSequenceNrAck, CumulativeWireSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ReadPacket _mcgen_PASTE2(McTemplateU0sdddd_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions
//

//
// Function for template "T_Throttled" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0_def
#define McTemplateU0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor
    )
{
#define McTemplateU0_ARGCOUNT 0

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0_ARGCOUNT + 1];

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0_def

//
// Function for template "T_MouseMove" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0dd_def
#define McTemplateU0dd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0dd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0,
    _In_ const signed int  _Arg1
    )
{
#define McTemplateU0dd_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0dd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0dd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0dd_def

//
// Function for template "T_MouseClick" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ddd_def
#define McTemplateU0ddd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ddd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const signed int  _Arg2
    )
{
#define McTemplateU0ddd_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ddd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ddd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ddd_def

//
// Function for template "T_FrameMark" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0df_def
#define McTemplateU0df_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0df_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0,
    _In_ const float  _Arg1
    )
{
#define McTemplateU0df_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0df_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const float)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0df_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0df_def

//
// Function for template "T_ThreadID" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ds_def
#define McTemplateU0ds_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ds_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const signed int  _Arg0,
    _In_opt_ PCSTR  _Arg1
    )
{
#define McTemplateU0ds_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ds_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : "NULL",
                        (_Arg1 != NULL) ? (ULONG)((strlen(_Arg1) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ds_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ds_def

//
// Function for template "T_Mark" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0s_def
#define McTemplateU0s_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0s_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0
    )
{
#define McTemplateU0s_ARGCOUNT 1

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0s_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0s_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0s_def

//
// Function for template "T_Start" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sd_def
#define McTemplateU0sd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const signed int  _Arg1
    )
{
#define McTemplateU0sd_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sd_def

//
// Function for template "T_Mark2I" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sdd_def
#define McTemplateU0sdd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sdd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const signed int  _Arg2
    )
{
#define McTemplateU0sdd_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sdd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sdd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sdd_def

//
// Function for template "T_Mark3I" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sddd_def
#define McTemplateU0sddd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sddd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const signed int  _Arg2,
    _In_ const signed int  _Arg3
    )
{
#define McTemplateU0sddd_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sddd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sddd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sddd_def

//
// Function for template "T_Mark4I" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sdddd_def
#define McTemplateU0sdddd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sdddd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const signed int  _Arg2,
    _In_ const signed int  _Arg3,
    _In_ const signed int  _Arg4
    )
{
#define McTemplateU0sdddd_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sdddd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sdddd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sdddd_def

//
// Function for template "T_End" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sdf_def
#define McTemplateU0sdf_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sdf_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const float  _Arg2
    )
{
#define McTemplateU0sdf_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sdf_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const float)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sdf_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sdf_def

//
// Function for template "T_Mark1F" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sf_def
#define McTemplateU0sf_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sf_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const float  _Arg1
    )
{
#define McTemplateU0sf_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sf_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const float)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sf_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sf_def

//
// Function for template "T_Mark2F" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sff_def
#define McTemplateU0sff_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sff_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const float  _Arg1,
    _In_ const float  _Arg2
    )
{
#define McTemplateU0sff_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sff_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const float)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const float)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sff_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sff_def

//
// Function for template "T_Mark3F" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sfff_def
#define McTemplateU0sfff_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sfff_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const float  _Arg1,
    _In_ const float  _Arg2,
    _In_ const float  _Arg3
    )
{
#define McTemplateU0sfff_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sfff_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const float)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const float)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const float)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sfff_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sfff_def

//
// Function for template "T_Mark4F" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sffff_def
#define McTemplateU0sffff_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sffff_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_ const float  _Arg1,
    _In_ const float  _Arg2,
    _In_ const float  _Arg3,
    _In_ const float  _Arg4
    )
{
#define McTemplateU0sffff_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sffff_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const float)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const float)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const float)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const float)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sffff_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sffff_def

//
// Function for template "T_Mark1S" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ss_def
#define McTemplateU0ss_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ss_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_opt_ PCSTR  _Arg1
    )
{
#define McTemplateU0ss_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ss_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : "NULL",
                        (_Arg1 != NULL) ? (ULONG)((strlen(_Arg1) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ss_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ss_def

//
// Function for template "T_Mark2S" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0sss_def
#define McTemplateU0sss_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0sss_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCSTR  _Arg0,
    _In_opt_ PCSTR  _Arg1,
    _In_opt_ PCSTR  _Arg2
    )
{
#define McTemplateU0sss_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0sss_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : "NULL",
                        (_Arg0 != NULL) ? (ULONG)((strlen(_Arg0) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : "NULL",
                        (_Arg1 != NULL) ? (ULONG)((strlen(_Arg1) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : "NULL",
                        (_Arg2 != NULL) ? (ULONG)((strlen(_Arg2) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0sss_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0sss_def

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
}
#endif
